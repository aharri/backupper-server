#!/bin/sh
# 
# Copyright (c) 2006,2007,2008,2009,2011 Antti Harri <iku@openbsd.fi>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

####################################
# for configuration check
#
# config/filters{,.sample}/
# config/backup.conf{,.sample}
# config/dump.conf{,.sample}
#
####################################

# defaults, the same as in backup.conf.sample
backups=/backups
min_backups=3
max_backups=250
mailto="root"
debug=
rsync_opts=
minimum_space=3
minimum_inodes=10000
backup_jobs=

# Other variables.
task_count=0
task_successes=0

# default umask
umask 077

# paths where to look for installed utilities
PATH=/root/bin:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
BASE=$(cd -- "$(dirname -- "$0")"; pwd)

# where is the ssh pubkey for root user to access remote clients
ssh_key="$BASE/config/ssh_key"

if [ ! -e "$BASE/config/backup.conf" ]; then
	echo "Edit configuration: $BASE/config/backup.conf"
	exit 1
fi

# Load functions & configuration.
. "$BASE/share/openbsd-install.sub"
. "$BASE/share/opsys.sh"
. "$BASE/share/helpers.sh"
. "$BASE/share/functions.sh"
. "$BASE/config/backup.conf"

# Call function to to check tool requirements.
required_tools="rm ls date df kill ping mail tr ssh find dirname basename
tail sort head install wc du bc cut awk uname whoami pgrep rsync"
check_required_tools

# Check that there aren't other processes running
check_backup_process

# Call function to parse command line arguments.
parse_arguments $@

# Call function to install signal traps and init other stuff.
run_init

# Call function to check and parse backup jobs.
check_configured_jobs

backup_loop()
{

	local ssh_verbose; ssh_verbose=
	if [ "$debug" = 'YES' ]; then
		ssh_verbose='-vv'
	fi

	local socket
	local sockets; sockets=
	local tmp_filter_file
	for backup_job in $parsed_jobs; do
	
		# Get _target, _user, _host and _login
		parse_target "$backup_job"

		filter_name=$(echo "$backup_job" | cut -f 4 -d ':')

		if [ "$_host" != "localhost" ]; then
			ping -w 1 -c 1 "${_host}" 1>/dev/null 2>/dev/null
			if [ "$?" -ne 0 ]; then
				printf '%s\n' "[SKIPPING] \"$_host\" is currently unavailable" | log
				continue 1
			fi
		fi

		printf '%s\n' "Truncating filter file" | debuglog
		tmp_filter_file="$TMPDIR/tempfiles/filter"
		echo -n '' > "$tmp_filter_file"

		task_count=$((task_count + 1))
		printf '%s\n' "\"$_host\" is alive" | log

		# Check for incomplete installation.
		check_ssh_keyfile "$_host"
		if [ "$?" -ne 0 ]; then
			printf '%s\n' "[SKIPPING] You don't have host key set. \"ssh ${_host}\" and accept signature." | log
			continue
		fi

		# Check for existing socket
		socket="${TMPDIR}/sockets/$_login"
		echo "$sockets" | fgrep -q -w -e "$_login"
		if [ "$?" -ne 0 ] && [ "$_host" != "localhost" ]; then
			# Open a connection to the remote host and
			# create a control socket
			# ssh -S /tmp/ssh_socket -M -N -f host.example.com
			ssh \
				-S "$socket" \
				-M \
				-N \
				-o PasswordAuthentication=no \
				-o BatchMode=yes \
				-i "$ssh_key" \
				-f "$_login" 2>&1 | debuglog
			if [ "$?" -ne 0 ]; then
				printf '%s\n' "[SKIPPING] failed to create ssh master socket for $_login" | log
				continue
			fi
			sockets="$sockets $_login"
			printf '%s\n' "Created socket for \"$_login\"" | debuglog
		fi

		last_backup_dir=$(find "${backups}/${_login}/${filter_name}/" \
			-maxdepth 1 \
			-name "????-??-??-??" | sort -n | tail -n 1)

		date=$(date +%Y-%m-%d-%H)
		new_dir="${backups}/${_login}/${filter_name}/${date}"

		# Previous backup found -> use it as base.
		local rsync_last_backup_dir; rsync_last_backup_dir=
		if [ -n "$last_backup_dir" ]; then
			rsync_last_backup_dir="--link-dest=$last_backup_dir"
		fi

		if [ ! -f "${BASE}/config/filters/${filter_name}" ]; then
			# Non-fatal, continue.
			printf '%s\n' "[SKIPPING] Filter not found. Please check configuration." | log
			continue 1
		fi

		local i
		for i in "generic" "generic:${_login}" "$filter_name"; do
			if [ -f "$BASE/config/filters/$i" ]; then
				cat "$BASE/config/filters/$i" >> "$tmp_filter_file"
			fi
		done

		local output
		local rsync_ret
		# Everything ready and initialized!
		# The following -e specification needs to be indented with spaces
		# because rsync is crappy!
		if [ "$_host" = "localhost" ]; then
			rsync \
				$rsync_opts \
				-a \
				--delete-after \
				--delete-excluded \
				--numeric-ids \
				--filter=". $tmp_filter_file" \
				$rsync_last_backup_dir \
				"/" \
				"${new_dir}/" > "${TMPDIR}/rsync_output" 2>&1
		else
			rsync \
				$rsync_opts \
				-a -z \
				-e "ssh $ssh_verbose -S $socket -o PasswordAuthentication=no -o BatchMode=yes" \
				--rsync-path="$_cmd" \
				--delete-after \
				--delete-excluded \
				--numeric-ids \
				--filter=". $tmp_filter_file" \
				$rsync_last_backup_dir \
				"${_login}:/" \
				"${new_dir}/" > "${TMPDIR}/rsync_output" 2>&1
		fi
		rsync_ret=$?
		local ret

		# Acceptable (= clean) exit codes are: 0, 23 and 24
		for ret in 0 23 24; do 
			if [ "$ret" -eq "$rsync_ret" ]; then
				task_successes=$((task_successes + 1))
				if [ "$debug" = "YES" ]; then
					printf '%s\n' "[SUCCESSFUL=${rsync_ret}] \"${_login}\": $filter_name" | log
				else
					printf '%s\n' "[SUCCESFUL] \"${_login}\": $filter_name" | log
				fi
				rm -f "${TMPDIR}/rsync_output"
				continue 2
			fi
		done
		printf '[FAILED=%s] output follows:\n' "$rsync_ret" | log
		cat "${TMPDIR}/rsync_output" | log
		rm -f "${TMPDIR}/rsync_output"
		rm -rf "$new_dir"
	done
}

# Finally call the monster!
backup_loop
