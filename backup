#!/bin/sh
# 
# $Id: backup,v 1.13 2008/03/29 19:22:04 iku Exp $
#
# Copyright (c) 2006,2007,2008 Antti Harri <iku@openbsd.fi>
#
# TODO:
# - Better quit handling regarding mailing of 
#   output when error occurs.

####################################
# do not edit unless you know what
# you're actually doing.
#
# for configuration check
# config/filters/
# config/backup.conf{,.sample}
# config/dump.conf{,.sample}
####################################

# defaults
mount_ro=YES
mount_check=
backup_jobs=
backups=/backups
keep_backups=5
mailto="root"
debug=NO
io_timeout=600
minimum_space=3
minimum_inodes=10000
filters=
#
# below this you shouldn't modify
#

filter_generic=

# default umask
umask 077

# paths where to look for installed utilities
PATH=/root/bin:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
BASE=$(cd -- "$(dirname -- "$0")"; pwd)
TMPDIR=$(mktemp -d /tmp/backup.XXXXXXXXX) || exit 1

if [ ! -e "$BASE/config/backup.conf" ]; then
	echo "Edit configuration: $BASE/config/backup.conf"
	exit 1
fi

# pick up functions & defaults
. "$BASE/libexec/functions.sh"
. "$BASE/config/backup.conf"

# Mount point check, avoid trashing discs where
# backups don't belong to!
if [ -n "$mount_check" ]; then
	mount | grep -q "^/dev/${mount_check} "
	if [ "$?" -ne 0 ]; then
		printf '%s\n' "[QUITING] $mount_check is not mounted currently!" | log
	fi
fi

# install signal traps
trap : INT
printf '%s\n' "Installed signal traps" | log

# where is ssh pubkey for root user in remote clients
ssh_key="$BASE/config/ssh_key"

# section: check for missing programs
required="
	rm ls date df kill
	ping
	mail tr ssh find dirname basename tail sort head install wc du bc cut awk
	rsync" # sudo-backup-wrapper"

for util in $required; do
	foo=$(which $util)
	if [ "$?" = 0 ]; then
		printf '%s\n' "found util: $foo" | debuglog
	elif [ "$util" = "sudo-backup-wrapper" ]; then
		printf '%s\n' "sudo-backup-wrapper is included with this software package." | log
		printf '%s\n' "Refer to the documentation how to install it approriately." | log
		exit 1
	else
		printf '%s\n' "You are missing $util, please install it" | log
		exit 1
	fi
done
printf '%s\n' "Found all required tools" | log

if [ -f "$BASE/config/filters/generic" ]; then
	filter_generic=--filter=". $BASE/config/filters/generic"
fi

# Check jobs
# FIXME: exiting here will not mail the logs: create clean up routine
if [ -z "$backup_jobs" ]; then 
	printf '%s\n' "[QUITING] No backup jobs defined!" | log
	exit 1
fi
parse_jobs
if [ -z "$parsed_jobs" ]; then 
	printf '%s\n' "[QUITING] Nothing to do!" | log
	# Dump to an external hard drive.
	if [ "$exec_dump" = "YES" ]; then
		$BASE/dumpfs
	fi
	quit_handler
fi

printf '%s\n' "Truncating logs/last_run.log" | debuglog
echo -n "" > "${BASE}/logs/last_run.log"

# It needs to be mounted R/W for rsync.
if [ "$mount_ro" = "YES" -a -n "$mount_check" ]; then
	printf '%s\n' "Mounting $mount_check R/W" | debuglog
	mount -u -f -w /dev/"$mount_check"
fi

local sockets=
for backup_job in $parsed_jobs; do

	local socket="${TMPDIR}/%r.%h:%p"
	machine=$(echo "$backup_job" | cut -f 1 -d ':')
	filter_name=$(echo "$backup_job" | cut -f 4 -d ':')

	ping -w 1 -c 1 "${machine}" 1>/dev/null 2>/dev/null
	if [ "$?" -eq 0 ]; then
		printf '%s\n' "\"$machine\" is alive" | log

		# Check for incomplete installation.
		check_ssh_keyfile "$machine"
		if [ "$?" -ne 0 ]; then
			printf '%s\n' "[SKIPPING] You don't have host key set. \"ssh ${machine}\" and accept signature." | log
			continue
		fi

		# Check for existing socket
		echo "$sockets" | fgrep -q -w -e "$machine"
		if [ "$machine" != "localhost" ] && [ "$?" -ne 0 ]; then
			# Open a connection to the remote host and
			# create a control socket
			# ssh -S /tmp/ssh_socket -M -N -f host.example.com
			ssh \
				-S "$socket" \
				-M \
				-N \
				-l "_backup" \
				-o PasswordAuthentication=no \
				-o BatchMode=yes \
				-i "$ssh_key" \
				-f "$machine"
			# FIXME: quit handler
			if [ "$?" -ne 0 ]; then
				printf '%s\n' "[SKIPPING] failed to create ssh master socket" | log
				continue
			fi
			sockets="$sockets $machine"
			printf '%s\n' "Created socket for \"$machine\"" | debuglog
		fi

		last_backup_dir=$(find "${backups}/${machine}/${filter_name}/" \
			-maxdepth 1 \
			-name "????-??-??-??" | sort -n | tail -n 1)

		date=$(date +%Y-%m-%d-%H)
		new_dir="${backups}/${machine}/${filter_name}/${date}"

		# create empty dir
		printf '%s\n' "about to create: $new_dir" | debuglog
		mkdir "$new_dir"
		if [ ! -d "$new_dir" ]; then
			printf '%s\n' "[QUITING] failed to create ${new_dir}" | log
			# FIXME: quit handler
			break
		fi

		# Previous backup found -> copy it to be as base.
		local rsync_last_backup_dir=
		if [ -n "$last_backup_dir" ]; then
			rsync_last_backup_dir="--link-dest=$last_backup_dir"
		fi

		local filter_machine=
		local filter_machine_generic=

		if [ -f "${BASE}/config/filters/generic_${machine}" ]; then
			filter_generic_machine=--filter=". ${BASE}/config/filters/generic_${machine}"
		fi
		if [ -f "${BASE}/config/filters/${filter_name}" ]; then
			filter_machine=--filter=". ${BASE}/config/filters/${filter_name}"
		else
			# Non-fatal, continue.
			printf '%s\n' "[SKIPPING] Filter not found. Please check configuration." | log
			continue
		fi

		# Everything ready and initialized!
		# The following -e specification needs to be indented with spaces
		# because rsync is crappy!
		if [ "$machine" = "localhost" ]; then
			rsync \
				-a -ii -vv \
				--log-file=${BASE}/logs/last_run.log \
				--log-file-format="%i %f" \
				--delete-after \
				--delete-excluded \
				--numeric-ids \
				$rsync_last_backup_dir \
				"$filter_generic" \
				"$filter_generic_machine" \
				"$filter_machine" \
				"/" \
				"${new_dir}/" 2>&1 | cmdlog
		else
			rsync \
				-azvvv \
				-e "ssh \
                    -l _backup \
                    -S $socket \
                    -o PasswordAuthentication=no \
                    -o BatchMode=yes" \
				--rsync-path=/home/_backup/backup_wrapper.sh \
				--log-file=${BASE}/logs/last_run.log \
				--log-file-format="%i %f" \
				--delete-after \
				--delete-excluded \
				--numeric-ids \
				--timeout=$io_timeout \
				$rsync_last_backup_dir \
				"$filter_generic" \
				"$filter_generic_machine" \
				"$filter_machine" \
				"${machine}:/" \
				"${new_dir}/" 2>&1 | cmdlog
		fi

		local rsync_ret=$?
		local ret

		# Acceptable (= clean) exit codes are: 0, 23 and 24
		for ret in 0 23 24; do 
			if [ "$ret" -eq "$rsync_ret" ]; then
				if [ "$debug" = "YES" ]; then
					printf '%s\n' "[SUCCESSFUL=${rsync_ret}] \"${machine}\": $filter_name" | log
				else
					printf '%s\n' "[SUCCESFUL] \"${machine}\": $filter_name" | log
				fi
				# Clear command log
				echo -n '' > "${BASE}/logs/cmd.log"
				continue 2
			fi
		done
		printf '%s\n' "[FAILED=${rsync_ret}] output follows:" | log
		cat "${BASE}/logs/cmd.log" | log
		echo -n '' > "${BASE}/logs/cmd.log"
		rm -rf "$new_dir"
	else
		printf '%s\n' "[SKIPPING] \"$machine\" is currently unavailable" | log
	fi
done

if [ "$mount_ro" = "YES" -a -n "$mount_check" ]; then
	printf '%s\n' "Mounting $mount_check R/O" | debuglog
	sync; sync; sync
	mount -u -r /dev/"$mount_check"
fi

# Close sockets.
# FIXME: quit handler
for socket in $sockets; do
	ssh -S "${TMPDIR}/%r.%h:%p" -l "_backup" -O exit "$socket"
	if [ -f "${TMPDIR}/_backup.${socket}:22" ]; then
		rm "${TMPDIR}/_backup.${socket}:22"
		printf '%s\n' "Removed socket for $socket" | debuglog
	fi
done
rmdir "$TMPDIR"

# Mail the results.
if [ -n "$mailto" ]; then
	#echo "$debug_str" | mail -s "Backup log" "$mailto"
	mail -s "Backup log" "$mailto" < "${BASE}/logs/system.log" && (echo -n "" > "${BASE}/logs/system.log")
fi

# Dump to an external hard drive.
if [ "$exec_dump" = "YES" ]; then
	$BASE/dumpfs
fi

if [ "$?" -gt 0 ]; then
	printf '%s\n' "Dump was not succesful" | debuglog
fi

quit_handler
