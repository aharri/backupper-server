#!/bin/sh
# 
# $Id: backup,v 1.16 2009/02/25 09:55:00 iku Exp $
#
# Copyright (c) 2006,2007,2008,2009 Antti Harri <iku@openbsd.fi>
#
# TODO:
# - Better quit handling regarding mailing of 
#   output when error occurs.

####################################
# for configuration check
#
# config/filters/
# config/backup.conf{,.sample}
# config/dump.conf{,.sample}
#
####################################

# defaults
backup_jobs=
backups=/backups
keep_backups=5
mailto="root"
debug=NO
io_timeout=600
minimum_space=3
minimum_inodes=10000
filters=

# default umask
umask 077

# paths where to look for installed utilities
PATH=/root/bin:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
BASE=$(cd -- "$(dirname -- "$0")"; pwd)
TMPDIR=$(mktemp -d /tmp/backup.XXXXXXXXX) || exit 1
TMP_filter_file="${TMPDIR}/rsync_filters"

# where is the ssh pubkey for root user to access remote clients
ssh_key="$BASE/config/ssh_key"

if [ ! -e "$BASE/config/backup.conf" ]; then
	echo "Edit configuration: $BASE/config/backup.conf"
	exit 1
fi

# Load functions & configuration.
. "$BASE/share/opsys.sh"
. "$BASE/share/helpers.sh"
. "$BASE/share/functions.sh"
. "$BASE/config/backup.conf"

# Call function to to check tool requirements.
required_tools="rm ls date df kill ping mail tr ssh find dirname basename
tail sort head install wc du bc cut awk uname whoami pgrep rsync"
check_required_tools

# Check that there aren't other processes running
check_backup_process

# Call function to parse command line arguments.
parse_arguments $@

# Call function to install signal traps.
trap_signals

# Call function to check and parse backup jobs.
check_configured_jobs

backup_loop()
{

	local ssh_verbose; ssh_verbose=
	if [ "$debug" = 'YES' ]; then
		ssh_verbose='-vv'
	fi
	
	local sockets; sockets=
	local task_count; task_count=0
	local task_successes; task_successes=0
	for backup_job in $parsed_jobs; do
	
		local socket; socket="${TMPDIR}/%r.%h:%p"
		# Get _target, _user, _host and _login
		parse_target "$backup_job"

		filter_name=$(echo "$backup_job" | cut -f 4 -d ':')

		if [ "$_host" != "localhost" ]; then
			ping -w 1 -c 1 "${_host}" 1>/dev/null 2>/dev/null
			if [ "$?" -ne 0 ]; then
				printf '%s\n' "[SKIPPING] \"$_host\" is currently unavailable" | log
				continue 1
			fi
		fi

		printf '%s\n' "Truncating filter file" | debuglog
		echo -n '' > "$TMP_filter_file"

		task_count=$((task_count + 1))
		printf '%s\n' "\"$_host\" is alive" | log

		# Check for incomplete installation.
		check_ssh_keyfile "$_host"
		if [ "$?" -ne 0 ]; then
			printf '%s\n' "[SKIPPING] You don't have host key set. \"ssh ${_host}\" and accept signature." | log
			continue
		fi

		# Check for existing socket
		echo "$sockets" | fgrep -q -w -e "$_login"
		if [ "$?" -ne 0 ] && [ "$_host" != "localhost" ]; then
			# Open a connection to the remote host and
			# create a control socket
			# ssh -S /tmp/ssh_socket -M -N -f host.example.com
			ssh \
				-S "$socket" \
				-M \
				-N \
				-o PasswordAuthentication=no \
				-o BatchMode=yes \
				-i "$ssh_key" \
				-f "$_login"
			# FIXME: quit handler
			if [ "$?" -ne 0 ]; then
				printf '%s\n' "[SKIPPING] failed to create ssh master socket for $_login" | log
				continue
			fi
			sockets="$sockets $_login"
			printf '%s\n' "Created socket for \"$_login\"" | debuglog
		fi

		last_backup_dir=$(find "${backups}/${_login}/${filter_name}/" \
			-maxdepth 1 \
			-name "????-??-??-??" | sort -n | tail -n 1)

		date=$(date +%Y-%m-%d-%H)
		new_dir="${backups}/${_login}/${filter_name}/${date}"

		# Previous backup found -> use it as base.
		local rsync_last_backup_dir; rsync_last_backup_dir=
		if [ -n "$last_backup_dir" ]; then
			rsync_last_backup_dir="--link-dest=$last_backup_dir"
		fi

		if [ ! -f "${BASE}/config/filters/${filter_name}" ]; then
			# Non-fatal, continue.
			printf '%s\n' "[SKIPPING] Filter not found. Please check configuration." | log
			continue 1
		fi

		local i
		for i in "generic" "generic:${_login}" "$filter_name"; do
			if [ -f "$BASE/config/filters/$i" ]; then
				cat "$BASE/config/filters/$i" >> "$TMP_filter_file"
			fi
		done

		local output
		local rsync_ret
		# Everything ready and initialized!
		# The following -e specification needs to be indented with spaces
		# because rsync is crappy!
		if [ "$_host" = "localhost" ]; then
			rsync \
				$rsync_dry_run \
				-a \
				--delete-after \
				--delete-excluded \
				--numeric-ids \
				--filter=". $TMP_filter_file" \
				$rsync_last_backup_dir \
				"/" \
				"${new_dir}/" > "${TMPDIR}/rsync_output" 2>&1
		else
			rsync \
				$rsync_dry_run \
				-a -z \
				-e "ssh $ssh_verbose \
                                -S $socket \
                                -o PasswordAuthentication=no \
                                -o BatchMode=yes" \
				--rsync-path=/home/_backup/backup_wrapper.sh \
				--delete-after \
				--delete-excluded \
				--numeric-ids \
				--timeout=$io_timeout \
				--filter=". $TMP_filter_file" \
				$rsync_last_backup_dir \
				"${_login}:/" \
				"${new_dir}/" > "${TMPDIR}/rsync_output" 2>&1
		fi
		rsync_ret=$?
		local ret

		# Acceptable (= clean) exit codes are: 0, 23 and 24
		for ret in 0 23 24; do 
			if [ "$ret" -eq "$rsync_ret" ]; then
				task_successes=$((task_successes + 1))
				if [ "$debug" = "YES" ]; then
					printf '%s\n' "[SUCCESSFUL=${rsync_ret}] \"${_login}\": $filter_name" | log
				else
					printf '%s\n' "[SUCCESFUL] \"${_login}\": $filter_name" | log
				fi
				rm -f "${TMPDIR}/rsync_output"

				# Create the locate DB
				#create_db "${machine}/${filter_name}/${date}/" "${backups}/${machine}/${filter_name}/${date}.db"

				continue 2
			fi
		done
		printf '[FAILED=%s] output follows:\n' "$rsync_ret" | log
		cat "${TMPDIR}/rsync_output" | log
		rm -f "${TMPDIR}/rsync_output"
		rm -rf "$new_dir"
	done
	
	rm -f "$TMP_filter_file"

	# Close sockets.
	# FIXME: quit handler
	for socket in $sockets; do
		# Get _target, _user, _host and _login
		parse_target "$socket"
		ssh -S "${TMPDIR}/%r.%h:%p" -l "$_user" -O exit "$_host" 2>&1 | debuglog
		if [ -f "${TMPDIR}/${_user}.${_host}:22" ]; then
			rm "${TMPDIR}/${_user}.${_host}:22"
			printf '%s\n' "Removed socket for $socket" | debuglog
		fi
	done
	
	# Mail the results.
	if [ -n "$mailto" ]; then
		hostname=$(hostname)
		mail -s "[$hostname] Backup log $task_successes/$task_count" "$mailto" < "${BASE}/logs/system.log" && (echo -n "" > "${BASE}/logs/system.log")
	fi
	
	
}

# Finally call the monster!
backup_loop

# Dump to an external hard drive.
if [ "$exec_dump" = "YES" ]; then
	$BASE/dumpfs
	if [ "$?" -gt 0 ]; then
		printf '%s\n' "Dump was not succesful" | debuglog
	fi
fi

quit_handler
