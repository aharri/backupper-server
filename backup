#!/bin/sh
# 
# $Id: backup,v 1.16 2009/02/25 09:55:00 iku Exp $
#
# Copyright (c) 2006,2007,2008,2009 Antti Harri <iku@openbsd.fi>
#
# TODO:
# - Better quit handling regarding mailing of 
#   output when error occurs.

####################################
# for configuration check
#
# config/filters/
# config/backup.conf{,.sample}
# config/dump.conf{,.sample}
#
####################################

# defaults
backup_jobs=
backups=/backups
keep_backups=5
mailto="root"
debug=NO
io_timeout=600
minimum_space=3
minimum_inodes=10000
filters=

# default umask
umask 077

# paths where to look for installed utilities
PATH=/root/bin:/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin
BASE=$(cd -- "$(dirname -- "$0")"; pwd)
TMPDIR=$(mktemp -d /tmp/backup.XXXXXXXXX) || exit 1
TMP_filter_file="${TMPDIR}/rsync_filters"

# where is the ssh pubkey for root user to access remote clients
ssh_key="$BASE/config/ssh_key"

# Required tools
required_tools="rm ls date df kill ping mail tr ssh find dirname basename
	tail sort head install wc du bc cut awk uname rsync"

if [ ! -e "$BASE/config/backup.conf" ]; then
	echo "Edit configuration: $BASE/config/backup.conf"
	exit 1
fi

# Load functions & configuration.
. "$BASE/share/opsys.sh"
. "$BASE/share/helpers.sh"
. "$BASE/share/functions.sh"
. "$BASE/config/backup.conf"

# Call function to parse command line arguments.
parse_arguments $@

# Call function to install signal traps.
trap_signals

# Call function to to check tool requirements.
check_required_tools

# Call function to check and parse backup jobs.
check_configured_jobs

backup_loop()
{

	local ssh_verbose; ssh_verbose=
	if [ "$debug" = 'YES' ]; then
		ssh_verbose='-vv'
	fi
	
	local sockets; sockets=
	local task_count; task_count=0
	local task_successes; task_successes=0
	for backup_job in $parsed_jobs; do
	
		local socket; socket="${TMPDIR}/%r.%h:%p"
		machine=$(echo "$backup_job" | cut -f 1 -d ':')
		filter_name=$(echo "$backup_job" | cut -f 4 -d ':')

		if [ "$machine" != "localhost" ]; then
			ping -w 1 -c 1 "${machine}" 1>/dev/null 2>/dev/null
			if [ "$?" -ne 0 ]; then
				printf '%s\n' "[SKIPPING] \"$machine\" is currently unavailable" | log
				continue 1
			fi
		fi

		printf '%s\n' "Truncating filter file" | debuglog
		echo -n '' > "$TMP_filter_file"

		task_count=$((task_count + 1))
		printf '%s\n' "\"$machine\" is alive" | log

		# Check for incomplete installation.
		check_ssh_keyfile "$machine"
		if [ "$?" -ne 0 ]; then
			printf '%s\n' "[SKIPPING] You don't have host key set. \"ssh ${machine}\" and accept signature." | log
			continue
		fi

		# Check for existing socket
		echo "$sockets" | fgrep -q -w -e "$machine"
		if [ "$?" -ne 0 ] && [ "$machine" != "localhost" ]; then
			# Open a connection to the remote host and
			# create a control socket
			# ssh -S /tmp/ssh_socket -M -N -f host.example.com
			ssh \
				-S "$socket" \
				-M \
				-N \
				-l "_backup" \
				-o PasswordAuthentication=no \
				-o BatchMode=yes \
				-i "$ssh_key" \
				-f "$machine"
			# FIXME: quit handler
			if [ "$?" -ne 0 ]; then
				printf '%s\n' "[SKIPPING] failed to create ssh master socket" | log
				continue
			fi
			sockets="$sockets $machine"
			printf '%s\n' "Created socket for \"$machine\"" | debuglog
		fi

		last_backup_dir=$(find "${backups}/${machine}/${filter_name}/" \
			-maxdepth 1 \
			-name "????-??-??-??" | sort -n | tail -n 1)

		date=$(date +%Y-%m-%d-%H)
		new_dir="${backups}/${machine}/${filter_name}/${date}"

		# create empty dir
		printf '%s\n' "about to create: $new_dir" | debuglog
		mkdir "$new_dir"
		if [ ! -d "$new_dir" ]; then
			printf '%s\n' "[QUITING] failed to create ${new_dir}" | log
			# FIXME: quit handler
			break
		fi

		# Previous backup found -> use it as base.
		local rsync_last_backup_dir; rsync_last_backup_dir=
		if [ -n "$last_backup_dir" ]; then
			rsync_last_backup_dir="--link-dest=$last_backup_dir"
		fi

		if [ ! -f "${BASE}/config/filters/${filter_name}" ]; then
			# Non-fatal, continue.
			printf '%s\n' "[SKIPPING] Filter not found. Please check configuration." | log
			continue 1
		fi

		local i
		for i in "generic" "generic_${machine}" "$filter_name"; do
			if [ -f "$BASE/config/filters/$i" ]; then
				cat "$BASE/config/filters/$i" >> "$TMP_filter_file"
			fi
		done

		local output
		# Everything ready and initialized!
		# The following -e specification needs to be indented with spaces
		# because rsync is crappy!
		if [ "$machine" = "localhost" ]; then
			rsync \
				-a \
				--delete-after \
				--delete-excluded \
				--numeric-ids \
				--filter=". $TMP_filter_file" \
				$rsync_last_backup_dir \
				"/" \
				"${new_dir}/" > "${TMPDIR}/rsync_output" 2>&1
		else
			rsync \
				-a -z \
				-e "ssh $ssh_verbose \
                                -l _backup \
                                -S $socket \
                                -o PasswordAuthentication=no \
                                -o BatchMode=yes" \
				--rsync-path=/home/_backup/backup_wrapper.sh \
				--delete-after \
				--delete-excluded \
				--numeric-ids \
				--timeout=$io_timeout \
				--filter=". $TMP_filter_file" \
				$rsync_last_backup_dir \
				"${machine}:/" \
				"${new_dir}/" > "${TMPDIR}/rsync_output" 2>&1
		fi

		local rsync_ret; rsync_ret=$?
		local ret

		# Acceptable (= clean) exit codes are: 0, 23 and 24
		for ret in 0 23 24; do 
			if [ "$ret" -eq "$rsync_ret" ]; then
				task_successes=$((task_successes + 1))
				if [ "$debug" = "YES" ]; then
					printf '%s\n' "[SUCCESSFUL=${rsync_ret}] \"${machine}\": $filter_name" | log
				else
					printf '%s\n' "[SUCCESFUL] \"${machine}\": $filter_name" | log
				fi
				rm -f "${TMPDIR}/rsync_output"

				# Create the locate DB
				#create_db "${machine}/${filter_name}/${date}/" "${backups}/${machine}/${filter_name}/${date}.db"

				continue 2
			fi
		done
		printf '[FAILED=%s] output follows:\n' "$rsync_ret" | log
		cat "${TMPDIR}/rsync_output" | log
		rm -f "${TMPDIR}/rsync_output"
		rm -rf "$new_dir"
	done
	
	rm -f "$TMP_filter_file"
	
	# Close sockets.
	# FIXME: quit handler
	for socket in $sockets; do
		ssh -S "${TMPDIR}/%r.%h:%p" -l "_backup" -O exit "$socket" 2>&1 | debuglog
		if [ -f "${TMPDIR}/_backup.${socket}:22" ]; then
			rm "${TMPDIR}/_backup.${socket}:22"
			printf '%s\n' "Removed socket for $socket" | debuglog
		fi
	done
	
	# Mail the results.
	if [ -n "$mailto" ]; then
		hostname=$(hostname)
		mail -s "[$hostname] Backup log $task_successes/$task_count" "$mailto" < "${BASE}/logs/system.log" && (echo -n "" > "${BASE}/logs/system.log")
	fi
	
	
}

# Finally call the monster!
backup_loop

# Dump to an external hard drive.
if [ "$exec_dump" = "YES" ]; then
	$BASE/dumpfs
	if [ "$?" -gt 0 ]; then
		printf '%s\n' "Dump was not succesful" | debuglog
	fi
fi

quit_handler
